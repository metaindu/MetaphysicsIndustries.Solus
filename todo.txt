bug: when assigning a variable, any variables in its expression are
        automatically substituted if they already have values assigned. So:
    >>> x := y + z
    >>> y := a + b
    >>> w := y + z
    >>> vars
    x = y + z
    w = a + b + z
    y = a + b
    At this point, w is no longer defined in terms of y at all. If we delete y,
        w will be unchanged. It's relation to y is completely removed, simply
        because y was already defined when w was defined. That is not true for
        x, which remains exactly how it was defined. This discrepancy would
        likely be a surprise to the user.
    Basically, this is caused by calling PreliminaryEval on inputs. Probably
        we should call PreliminaryEval and just pass it an empty environment.
        That way, it wouldn't automatically resolve variable references.
should Expression.Clone be shallow or deep?
    or should it be removed altogether?
distinguish between tensors (vectors, matrices) and simple arrays
should arrays be indexed starting at zero or one?
    currently zero. that is common in programming.
    starting at one is common in mathematics
unify the namespace
    so that `vars` and `delete` and friends all work consistently and
    predictably
don't evaluate macros while parsing
don't require the SolusEnvironment while parsing
arbitrary rules for function arguments, e.g.:
    - like GreaterThanZero or
    - Matrix sized NxM
    - multiplication operator require that subsequent matrix arguments have
      matching inner dimensions, to perform typical matrix multiplication
similar checks on inputs to expression
a type system to support the above
maybe a "property system" in addition to, or in place of, said type system
markers of the type of the result of an expression (or return value of a
    function), based on inputs
figure out some solution to the problem of values being boxed and unboxed so
    much. It's causing lots of allocations and is just slow in general.
simple sets as IMathObject
intervals
    syntax
    intersects other interval
    interior
    closure
    interval closure/interval span (may require sets)
    is subinterval of
    is proper subinterval of
    bounded vs unbounded (requires infinity)
    IMathObject.IsSet(env) => true

more complicated expression-based sets
complex numbers
tensors of rank 3 or more
    including syntax
boolean true and false
piece-wise functions
parametric expressions, e.g. "sin(x) for 0<=x<2*pi" or "dist(r) for r in R"
sum function that can operate on parametrics. the big sigma symbol.
single component assignment?
    "c[2,3] := 4"
    varref array-index ':=' expr;
parametric array assignment
    "c[i,j] := sum(a[i][k]*b[k][j] for k=[0..n-1]) for i=[0..m-1],j=[0..p-1]"
    possible ambiguity:
        1 for i=... for j=...
        (1 for i=...) for j=...
        1 for i=(... for j=...)
    possible ambiguity:
        1 for i=... for j=...,k=...
        (1 for i=...) for j=...,k=...
        1 for i=(... for j=...),k=...
        1 for i=(... for j=...,k=...)
    "c[i,j] for i=[0..m-1],j=[0..p-1] := sum(a[i][k]*b[k][j] for k=[0..n-1])"
    varref array-index 'for' var-interval (',' var-interval) ':=' expr;
array comprehension
    "[ x*x for x=[1..5] ]" -> 1d array or vector
    "[ i*j for i=[1..w],j=[1..h] ]" -> 2d array or matrix
    "[ i*j*k for i=...,j=...,k=... ]" -> 3d array
    etc.
    array-comprehension = '[' expr 'for'
        var-interval ( ',' var-interval )* ']';
"help syntax" topics
    "help syntax array-literal"
    "help syntax component-access"
syntax for user-defined functions
    type checks/requirements
    return types
    docstrings
    `f(a:scalar) "calculate the thing" -> vector := [a, a+1, a+2]`
repl line continuation, so it doesn't all have to go on a single line
    wodehouse can do that, but that's python, so not much help
update IL compilation
syntax for variable number of arguments to a function
